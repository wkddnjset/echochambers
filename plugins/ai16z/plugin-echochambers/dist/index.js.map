{"version":3,"sources":["../src/index.ts","../src/echoChamberClient.ts","../src/interactions.ts","../src/environment.ts","../src/types.ts"],"sourcesContent":["import { elizaLogger, Client, IAgentRuntime, Plugin } from \"@ai16z/eliza\";\r\nimport { EchoChamberClient } from \"./echoChamberClient\";\r\nimport { InteractionClient } from \"./interactions\";\r\nimport { EchoChamberConfig } from \"./types\";\r\nimport { validateEchoChamberConfig } from \"./environment\";\r\n\r\n/**\r\n * Direct client interface for EchoChambers integration\r\n * Handles initialization and cleanup of the EchoChambers client and interaction handler\r\n */\r\nexport const EchoChamberClientInterface: Client = {\r\n    async start(runtime: IAgentRuntime) {\r\n        try {\r\n            // Validate configuration before starting\r\n            await validateEchoChamberConfig(runtime);\r\n\r\n            const apiUrl =\r\n                runtime.getSetting(\"ECHOCHAMBERS_API_URL\") ||\r\n                \"http://localhost:3001\";\r\n            const apiKey = runtime.getSetting(\"ECHOCHAMBERS_API_KEY\");\r\n\r\n            if (!apiKey) {\r\n                throw new Error(\"ECHOCHAMBERS_API_KEY is required\");\r\n            }\r\n\r\n            const config: EchoChamberConfig = {\r\n                apiUrl,\r\n                apiKey,\r\n                username:\r\n                    runtime.getSetting(\"ECHOCHAMBERS_USERNAME\") ||\r\n                    `agent-${runtime.agentId}`,\r\n                model: runtime.modelProvider,\r\n                defaultRoom:\r\n                    runtime.getSetting(\"ECHOCHAMBERS_DEFAULT_ROOM\") ||\r\n                    \"general\",\r\n            };\r\n\r\n            elizaLogger.log(\"Starting EchoChambers client...\");\r\n\r\n            // Initialize the API client\r\n            const client = new EchoChamberClient(runtime, config);\r\n            await client.start();\r\n\r\n            // Initialize the interaction handler\r\n            const interactionClient = new InteractionClient(client, runtime);\r\n            await interactionClient.start();\r\n\r\n            elizaLogger.success(\r\n                `‚úÖ EchoChambers client successfully started for character ${runtime.character.name}`\r\n            );\r\n\r\n            return { client, interactionClient };\r\n        } catch (error) {\r\n            elizaLogger.error(\"Failed to start EchoChambers client:\", error);\r\n            throw error;\r\n        }\r\n    },\r\n\r\n    async stop(runtime: IAgentRuntime) {\r\n        try {\r\n            elizaLogger.warn(\"Stopping EchoChambers client...\");\r\n\r\n            // Get client instances if they exist\r\n            const clients = (runtime as any).clients?.filter(\r\n                (c: any) =>\r\n                    c instanceof EchoChamberClient ||\r\n                    c instanceof InteractionClient\r\n            );\r\n\r\n            for (const client of clients) {\r\n                await client.stop();\r\n            }\r\n\r\n            elizaLogger.success(\"EchoChambers client stopped successfully\");\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error stopping EchoChambers client:\", error);\r\n            throw error;\r\n        }\r\n    },\r\n};\r\n\r\n/**\r\n * EchoChambers plugin definition\r\n * Enables ELIZA to interact with EchoChambers rooms by:\r\n * 1. Managing API communication through EchoChamberClient\r\n * 2. Processing messages and generating responses through InteractionClient\r\n */\r\nexport const echoChamberPlugin: Plugin = {\r\n    name: \"echochambers\",\r\n    description:\r\n        \"Plugin for interacting with EchoChambers API to enable multi-agent communication\",\r\n    actions: [], // No custom actions needed - core functionality handled by client\r\n    evaluators: [], // No custom evaluators needed\r\n    providers: [], // No custom providers needed\r\n    clients: [EchoChamberClientInterface],\r\n};\r\n\r\nexport default echoChamberPlugin;\r\n\r\n// Export types and classes\r\nexport * from \"./types\";\r\nexport { EchoChamberClient } from \"./echoChamberClient\";\r\nexport { InteractionClient } from \"./interactions\";\r\n","import { elizaLogger, IAgentRuntime } from \"@ai16z/eliza\";\r\nimport {\r\n    ChatMessage,\r\n    ChatRoom,\r\n    EchoChamberConfig,\r\n    ModelInfo,\r\n    ListRoomsResponse,\r\n    RoomHistoryResponse,\r\n    MessageResponse,\r\n} from \"./types\";\r\n\r\n/**\r\n * Maximum number of retries for API requests\r\n */\r\nconst MAX_RETRIES = 3;\r\n\r\n/**\r\n * Delay between retries in milliseconds\r\n */\r\nconst RETRY_DELAY = 5000;\r\n\r\n/**\r\n * EchoChamberClient handles communication between ELIZA and the EchoChambers platform.\r\n * Primary responsibilities:\r\n * 1. API communication\r\n * 2. Room management\r\n * 3. Message sending/receiving\r\n *\r\n * Error Handling:\r\n * - Automatic retry for failed API requests\r\n * - Graceful degradation on connection issues\r\n * - Detailed error logging\r\n */\r\nexport class EchoChamberClient {\r\n    private runtime: IAgentRuntime;\r\n    private config: EchoChamberConfig;\r\n    private apiUrl: string;\r\n    private modelInfo: ModelInfo;\r\n    private pollInterval: NodeJS.Timeout | null = null;\r\n    private watchedRoom: string | null = null;\r\n    private reconnectAttempts: number = 0;\r\n    private readonly maxReconnectAttempts: number = 5;\r\n\r\n    constructor(runtime: IAgentRuntime, config: EchoChamberConfig) {\r\n        this.runtime = runtime;\r\n        this.config = config;\r\n        this.apiUrl = `${config.apiUrl}/api/rooms`;\r\n        this.modelInfo = {\r\n            username: config.username || `agent-${runtime.agentId}`,\r\n            model: config.model || runtime.modelProvider,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the username configured for this client\r\n     */\r\n    public getUsername(): string {\r\n        return this.modelInfo.username;\r\n    }\r\n\r\n    /**\r\n     * Gets the model info for this client\r\n     */\r\n    public getModelInfo(): ModelInfo {\r\n        return { ...this.modelInfo };\r\n    }\r\n\r\n    /**\r\n     * Gets the current configuration\r\n     */\r\n    public getConfig(): EchoChamberConfig {\r\n        return { ...this.config };\r\n    }\r\n\r\n    private getAuthHeaders(): { [key: string]: string } {\r\n        return {\r\n            \"Content-Type\": \"application/json\",\r\n            \"x-api-key\": this.config.apiKey,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Sets a specific room to watch and process messages from\r\n     * @param roomId ID of the room to watch\r\n     * @throws {Error} If room not found\r\n     */\r\n    public async setWatchedRoom(roomId: string): Promise<void> {\r\n        try {\r\n            // Verify room exists\r\n            const rooms = await this.listRooms();\r\n            const room = rooms.find((r) => r.id === roomId);\r\n\r\n            if (!room) {\r\n                throw new Error(`Room ${roomId} not found`);\r\n            }\r\n\r\n            // Leave current watched room if any\r\n            if (this.watchedRoom) {\r\n                await this.leaveRoom(this.watchedRoom);\r\n            }\r\n\r\n            // Set new watched room\r\n            this.watchedRoom = roomId;\r\n            await this.joinRoom(roomId);\r\n\r\n            elizaLogger.success(`Now watching room: ${room.name}`);\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error setting watched room:\", error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the currently watched room ID\r\n     * @returns The watched room ID or null if no room is being watched\r\n     */\r\n    public getWatchedRoom(): string | null {\r\n        return this.watchedRoom;\r\n    }\r\n\r\n    /**\r\n     * Retries an operation with exponential backoff\r\n     * @param operation The async operation to retry\r\n     * @param retries Maximum number of retry attempts\r\n     * @throws {Error} If all retries fail\r\n     */\r\n    private async retryOperation<T>(\r\n        operation: () => Promise<T>,\r\n        retries: number = MAX_RETRIES\r\n    ): Promise<T> {\r\n        for (let i = 0; i < retries; i++) {\r\n            try {\r\n                return await operation();\r\n            } catch (error) {\r\n                if (i === retries - 1) throw error;\r\n                const delay = RETRY_DELAY * Math.pow(2, i);\r\n                elizaLogger.warn(`Retrying operation in ${delay}ms...`);\r\n                await new Promise((resolve) => setTimeout(resolve, delay));\r\n            }\r\n        }\r\n        throw new Error(\"Max retries exceeded\");\r\n    }\r\n\r\n    /**\r\n     * Handles reconnection attempts when polling fails\r\n     */\r\n    private async handleReconnection(): Promise<void> {\r\n        this.reconnectAttempts++;\r\n        if (this.reconnectAttempts <= this.maxReconnectAttempts) {\r\n            elizaLogger.warn(\r\n                `Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts})...`\r\n            );\r\n            await new Promise((resolve) => setTimeout(resolve, RETRY_DELAY));\r\n        } else {\r\n            elizaLogger.error(\r\n                \"Max reconnection attempts reached, stopping client\"\r\n            );\r\n            await this.stop();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initializes the EchoChamber client\r\n     * 1. Verifies API connection\r\n     * 2. Joins default room if specified\r\n     *\r\n     * @throws {Error} If API connection fails after max retries\r\n     */\r\n    public async start(): Promise<void> {\r\n        elizaLogger.log(\"üöÄ Starting EchoChamber client...\");\r\n        try {\r\n            // Verify connection by listing rooms\r\n            await this.retryOperation(() => this.listRooms());\r\n            elizaLogger.success(\r\n                `‚úÖ EchoChamber client successfully started for ${this.modelInfo.username}`\r\n            );\r\n\r\n            // Join default room if specified and no specific room is being watched\r\n            if (this.config.defaultRoom && !this.watchedRoom) {\r\n                await this.setWatchedRoom(this.config.defaultRoom);\r\n            }\r\n        } catch (error) {\r\n            elizaLogger.error(\"‚ùå Failed to start EchoChamber client:\", error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stops the client and cleans up resources\r\n     */\r\n    public async stop(): Promise<void> {\r\n        if (this.pollInterval) {\r\n            clearInterval(this.pollInterval);\r\n            this.pollInterval = null;\r\n        }\r\n\r\n        // Leave watched room if any\r\n        if (this.watchedRoom) {\r\n            try {\r\n                await this.leaveRoom(this.watchedRoom);\r\n                this.watchedRoom = null;\r\n            } catch (error) {\r\n                elizaLogger.error(\r\n                    `Error leaving room ${this.watchedRoom}:`,\r\n                    error\r\n                );\r\n            }\r\n        }\r\n\r\n        elizaLogger.log(\"Stopping EchoChamber client...\");\r\n    }\r\n\r\n    /**\r\n     * Lists available rooms, optionally filtered by tags\r\n     * @param tags Optional array of tags to filter rooms\r\n     * @returns Array of ChatRoom objects\r\n     * @throws {Error} If API request fails\r\n     */\r\n    public async listRooms(tags?: string[]): Promise<ChatRoom[]> {\r\n        try {\r\n            const url = new URL(this.apiUrl);\r\n            if (tags?.length) {\r\n                url.searchParams.append(\"tags\", tags.join(\",\"));\r\n            }\r\n\r\n            const response = await fetch(url.toString());\r\n            if (!response.ok) {\r\n                throw new Error(`Failed to list rooms: ${response.statusText}`);\r\n            }\r\n\r\n            const data = (await response.json()) as ListRoomsResponse;\r\n            return data.rooms;\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error listing rooms:\", error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Retrieves message history for a specific room\r\n     * @param roomId ID of the room to get history for\r\n     * @returns Array of ChatMessage objects\r\n     * @throws {Error} If API request fails\r\n     */\r\n    public async getRoomHistory(roomId: string): Promise<ChatMessage[]> {\r\n        return this.retryOperation(async () => {\r\n            const response = await fetch(`${this.apiUrl}/${roomId}/history`);\r\n            if (!response.ok) {\r\n                throw new Error(\r\n                    `Failed to get room history: ${response.statusText}`\r\n                );\r\n            }\r\n\r\n            const data = (await response.json()) as RoomHistoryResponse;\r\n            return data.messages;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sends a message to a specific room\r\n     * @param roomId ID of the room to send message to\r\n     * @param content Message content\r\n     * @returns The sent ChatMessage\r\n     * @throws {Error} If API request fails\r\n     */\r\n    public async sendMessage(\r\n        roomId: string,\r\n        content: string\r\n    ): Promise<ChatMessage> {\r\n        return this.retryOperation(async () => {\r\n            const response = await fetch(`${this.apiUrl}/${roomId}/message`, {\r\n                method: \"POST\",\r\n                headers: this.getAuthHeaders(),\r\n                body: JSON.stringify({\r\n                    content,\r\n                    sender: this.modelInfo,\r\n                }),\r\n            });\r\n\r\n            if (!response.ok) {\r\n                throw new Error(\r\n                    `Failed to send message: ${response.statusText}`\r\n                );\r\n            }\r\n\r\n            const data = (await response.json()) as MessageResponse;\r\n            return data.message;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Joins a room to begin receiving messages\r\n     * @param roomId ID of the room to join\r\n     * @throws {Error} If room not found or join fails\r\n     */\r\n    private async joinRoom(roomId: string): Promise<void> {\r\n        try {\r\n            const rooms = await this.listRooms();\r\n            const room = rooms.find((r) => r.id === roomId);\r\n\r\n            if (!room) {\r\n                throw new Error(`Room ${roomId} not found`);\r\n            }\r\n\r\n            // Join room using the join endpoint\r\n            const response = await fetch(`${this.apiUrl}/${roomId}/join`, {\r\n                method: \"POST\",\r\n                headers: this.getAuthHeaders(),\r\n                body: JSON.stringify(this.modelInfo),\r\n            });\r\n\r\n            if (!response.ok) {\r\n                throw new Error(`Failed to join room: ${response.statusText}`);\r\n            }\r\n\r\n            elizaLogger.success(`Joined room: ${room.name}`);\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error joining room:\", error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Leaves a room and stops receiving messages\r\n     * @param roomId ID of the room to leave\r\n     * @throws {Error} If leave request fails\r\n     */\r\n    private async leaveRoom(roomId: string): Promise<void> {\r\n        try {\r\n            // Leave room using the leave endpoint\r\n            const response = await fetch(`${this.apiUrl}/${roomId}/leave`, {\r\n                method: \"POST\",\r\n                headers: this.getAuthHeaders(),\r\n                body: JSON.stringify(this.modelInfo),\r\n            });\r\n\r\n            if (!response.ok) {\r\n                throw new Error(`Failed to leave room: ${response.statusText}`);\r\n            }\r\n\r\n            elizaLogger.success(`Left room: ${roomId}`);\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error leaving room:\", error);\r\n            throw error;\r\n        }\r\n    }\r\n}\r\n","import {\r\n    composeContext,\r\n    generateMessageResponse,\r\n    generateShouldRespond,\r\n    messageCompletionFooter,\r\n    shouldRespondFooter,\r\n    Content,\r\n    HandlerCallback,\r\n    IAgentRuntime,\r\n    Memory,\r\n    ModelClass,\r\n    State,\r\n    stringToUuid,\r\n    elizaLogger,\r\n    getEmbeddingZeroVector,\r\n} from \"@ai16z/eliza\";\r\nimport { EchoChamberClient } from \"./echoChamberClient\";\r\nimport { ChatMessage } from \"./types\";\r\n\r\nfunction createMessageTemplate(currentRoom: string, roomTopic: string) {\r\n    return (\r\n        `\r\n# About {{agentName}}:\r\n{{bio}}\r\n{{lore}}\r\n{{knowledge}}\r\n\r\nCurrent Room: ${currentRoom}\r\nRoom Topic: ${roomTopic}\r\n\r\n{{messageDirections}}\r\n\r\nRecent conversation history:\r\n{{recentMessages}}\r\n\r\nThread Context:\r\n{{formattedConversation}}\r\n\r\n# Task: Generate a response in the voice and style of {{agentName}} while:\r\n1. Staying relevant to the room's topic\r\n2. Maintaining conversation context\r\n3. Being helpful but not overly talkative\r\n4. Responding naturally to direct questions or mentions\r\n5. Contributing meaningfully to ongoing discussions\r\n\r\nRemember:\r\n- Keep responses concise and focused\r\n- Stay on topic for the current room\r\n- Don't repeat information already shared\r\n- Be natural and conversational\r\n` + messageCompletionFooter\r\n    );\r\n}\r\n\r\nfunction createShouldRespondTemplate(currentRoom: string, roomTopic: string) {\r\n    return (\r\n        `\r\n# About {{agentName}}:\r\n{{bio}}\r\n{{knowledge}}\r\n\r\nCurrent Room: ${currentRoom}\r\nRoom Topic: ${roomTopic}\r\n\r\nResponse options are [RESPOND], [IGNORE] and [STOP].\r\n\r\n{{agentName}} should:\r\n- RESPOND when:\r\n  * Directly mentioned or asked a question\r\n  * Can contribute relevant expertise to the discussion\r\n  * Topic aligns with their knowledge and background\r\n  * Conversation is active and engaging\r\n\r\n- IGNORE when:\r\n  * Message is not relevant to their expertise\r\n  * Already responded recently without new information to add\r\n  * Conversation has moved to a different topic\r\n  * Message is too short or lacks substance\r\n  * Other participants are handling the discussion well\r\n\r\n- STOP when:\r\n  * Asked to stop participating\r\n  * Conversation has concluded\r\n  * Discussion has completely diverged from their expertise\r\n  * Room topic has changed significantly\r\n\r\nRecent messages:\r\n{{recentMessages}}\r\n\r\nThread Context:\r\n{{formattedConversation}}\r\n\r\n# Task: Choose whether {{agentName}} should respond to the last message.\r\nConsider:\r\n1. Message relevance to {{agentName}}'s expertise\r\n2. Current conversation context\r\n3. Time since last response\r\n4. Value of potential contribution\r\n` + shouldRespondFooter\r\n    );\r\n}\r\n\r\nexport class InteractionClient {\r\n    private client: EchoChamberClient;\r\n    private runtime: IAgentRuntime;\r\n    private lastCheckedTimestamps: Map<string, string> = new Map();\r\n    private lastResponseTimes: Map<string, number> = new Map();\r\n    private messageThreads: Map<string, ChatMessage[]> = new Map();\r\n    private pollInterval: NodeJS.Timeout | null = null;\r\n\r\n    constructor(client: EchoChamberClient, runtime: IAgentRuntime) {\r\n        this.client = client;\r\n        this.runtime = runtime;\r\n    }\r\n\r\n    async start() {\r\n        const pollInterval = Number(\r\n            this.runtime.getSetting(\"ECHOCHAMBERS_POLL_INTERVAL\") || 120\r\n        );\r\n\r\n        const handleInteractionsLoop = () => {\r\n            this.handleInteractions();\r\n            this.pollInterval = setTimeout(\r\n                handleInteractionsLoop,\r\n                pollInterval * 1000\r\n            );\r\n        };\r\n\r\n        handleInteractionsLoop();\r\n    }\r\n\r\n    async stop() {\r\n        if (this.pollInterval) {\r\n            clearTimeout(this.pollInterval);\r\n            this.pollInterval = null;\r\n        }\r\n    }\r\n\r\n    private async buildMessageThread(\r\n        message: ChatMessage,\r\n        messages: ChatMessage[]\r\n    ): Promise<ChatMessage[]> {\r\n        const thread: ChatMessage[] = [];\r\n        const maxThreadLength = 10;\r\n\r\n        // Start with the current message\r\n        thread.push(message);\r\n\r\n        // Get recent messages in the same room, ordered by timestamp\r\n        const roomMessages = messages\r\n            .filter((msg) => msg.roomId === message.roomId)\r\n            .sort(\r\n                (a, b) =>\r\n                    new Date(b.timestamp).getTime() -\r\n                    new Date(a.timestamp).getTime()\r\n            );\r\n\r\n        // Add recent messages to provide context\r\n        for (const msg of roomMessages) {\r\n            if (thread.length >= maxThreadLength) break;\r\n            if (msg.id !== message.id) {\r\n                thread.unshift(msg);\r\n            }\r\n        }\r\n\r\n        return thread;\r\n    }\r\n\r\n    private shouldProcessMessage(\r\n        message: ChatMessage,\r\n        room: { topic: string }\r\n    ): boolean {\r\n        const modelInfo = this.client.getModelInfo();\r\n\r\n        // Don't process own messages\r\n        if (message.sender.username === modelInfo.username) {\r\n            return false;\r\n        }\r\n\r\n        // Check if we've processed this message before\r\n        const lastChecked =\r\n            this.lastCheckedTimestamps.get(message.roomId) || \"0\";\r\n        if (message.timestamp <= lastChecked) {\r\n            return false;\r\n        }\r\n\r\n        // Check rate limiting for responses\r\n        const lastResponseTime =\r\n            this.lastResponseTimes.get(message.roomId) || 0;\r\n        const minTimeBetweenResponses = 30000; // 30 seconds\r\n        if (Date.now() - lastResponseTime < minTimeBetweenResponses) {\r\n            return false;\r\n        }\r\n\r\n        // Check if message mentions the agent\r\n        const isMentioned = message.content\r\n            .toLowerCase()\r\n            .includes(`@${modelInfo.username.toLowerCase()}`);\r\n\r\n        // Check if message is relevant to room topic\r\n        const isRelevantToTopic = message.content\r\n            .toLowerCase()\r\n            .includes(room.topic.toLowerCase());\r\n\r\n        // Always process if mentioned, otherwise check relevance\r\n        return isMentioned || isRelevantToTopic;\r\n    }\r\n\r\n    private async handleInteractions() {\r\n        elizaLogger.log(\"Checking EchoChambers interactions\");\r\n\r\n        try {\r\n            const rooms = await this.client.listRooms();\r\n\r\n            for (const room of rooms) {\r\n                const messages = await this.client.getRoomHistory(room.id);\r\n\r\n                // Update message threads for the room\r\n                this.messageThreads.set(room.id, messages);\r\n\r\n                // Filter and process new messages\r\n                const newMessages = messages.filter((msg) =>\r\n                    this.shouldProcessMessage(msg, room)\r\n                );\r\n\r\n                // Process each new message\r\n                for (const message of newMessages) {\r\n                    await this.handleMessage(message, room.topic);\r\n\r\n                    // Update timestamps\r\n                    if (\r\n                        message.timestamp >\r\n                        (this.lastCheckedTimestamps.get(room.id) || \"0\")\r\n                    ) {\r\n                        this.lastCheckedTimestamps.set(\r\n                            room.id,\r\n                            message.timestamp\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n\r\n            elizaLogger.log(\"Finished checking EchoChambers interactions\");\r\n        } catch (error) {\r\n            elizaLogger.error(\r\n                \"Error handling EchoChambers interactions:\",\r\n                error\r\n            );\r\n        }\r\n    }\r\n\r\n    private async handleMessage(message: ChatMessage, roomTopic: string) {\r\n        try {\r\n            const roomId = stringToUuid(message.roomId);\r\n            const userId = stringToUuid(message.sender.username);\r\n\r\n            // Ensure connection exists\r\n            await this.runtime.ensureConnection(\r\n                userId,\r\n                roomId,\r\n                message.sender.username,\r\n                message.sender.username,\r\n                \"echochambers\"\r\n            );\r\n\r\n            // Build message thread for context\r\n            const thread = await this.buildMessageThread(\r\n                message,\r\n                this.messageThreads.get(message.roomId) || []\r\n            );\r\n\r\n            // Create memory object\r\n            const memory: Memory = {\r\n                id: stringToUuid(message.id),\r\n                userId,\r\n                agentId: this.runtime.agentId,\r\n                roomId,\r\n                content: {\r\n                    text: message.content,\r\n                    source: \"echochambers\",\r\n                    thread: thread.map((msg) => ({\r\n                        text: msg.content,\r\n                        sender: msg.sender.username,\r\n                        timestamp: msg.timestamp,\r\n                    })),\r\n                },\r\n                createdAt: new Date(message.timestamp).getTime(),\r\n                embedding: getEmbeddingZeroVector(),\r\n            };\r\n\r\n            // Check if we've already processed this message\r\n            const existing = await this.runtime.messageManager.getMemoryById(\r\n                memory.id\r\n            );\r\n            if (existing) {\r\n                elizaLogger.log(\r\n                    `Already processed message ${message.id}, skipping`\r\n                );\r\n                return;\r\n            }\r\n\r\n            // Save the message to memory\r\n            await this.runtime.messageManager.createMemory(memory);\r\n\r\n            // Compose state with thread context\r\n            let state = await this.runtime.composeState(memory);\r\n            state = await this.runtime.updateRecentMessageState(state);\r\n\r\n            // Decide whether to respond\r\n            const shouldRespondContext = composeContext({\r\n                state,\r\n                template:\r\n                    this.runtime.character.templates?.shouldRespondTemplate ||\r\n                    createShouldRespondTemplate(message.roomId, roomTopic),\r\n            });\r\n\r\n            const shouldRespond = await generateShouldRespond({\r\n                runtime: this.runtime,\r\n                context: shouldRespondContext,\r\n                modelClass: ModelClass.SMALL,\r\n            });\r\n\r\n            if (shouldRespond !== \"RESPOND\") {\r\n                elizaLogger.log(\r\n                    `Not responding to message ${message.id}: ${shouldRespond}`\r\n                );\r\n                return;\r\n            }\r\n\r\n            // Generate response\r\n            const responseContext = composeContext({\r\n                state,\r\n                template:\r\n                    this.runtime.character.templates?.messageHandlerTemplate ||\r\n                    createMessageTemplate(message.roomId, roomTopic),\r\n            });\r\n\r\n            const response = await generateMessageResponse({\r\n                runtime: this.runtime,\r\n                context: responseContext,\r\n                modelClass: ModelClass.SMALL,\r\n            });\r\n\r\n            if (!response || !response.text) {\r\n                elizaLogger.log(\"No response generated\");\r\n                return;\r\n            }\r\n\r\n            // Send response\r\n            const callback: HandlerCallback = async (content: Content) => {\r\n                const sentMessage = await this.client.sendMessage(\r\n                    message.roomId,\r\n                    content.text\r\n                );\r\n\r\n                // Update last response time\r\n                this.lastResponseTimes.set(message.roomId, Date.now());\r\n\r\n                const responseMemory: Memory = {\r\n                    id: stringToUuid(sentMessage.id),\r\n                    userId: this.runtime.agentId,\r\n                    agentId: this.runtime.agentId,\r\n                    roomId,\r\n                    content: {\r\n                        text: sentMessage.content,\r\n                        source: \"echochambers\",\r\n                        action: content.action,\r\n                        thread: thread.map((msg) => ({\r\n                            text: msg.content,\r\n                            sender: msg.sender.username,\r\n                            timestamp: msg.timestamp,\r\n                        })),\r\n                    },\r\n                    createdAt: new Date(sentMessage.timestamp).getTime(),\r\n                    embedding: getEmbeddingZeroVector(),\r\n                };\r\n\r\n                await this.runtime.messageManager.createMemory(responseMemory);\r\n                return [responseMemory];\r\n            };\r\n\r\n            // Send the response and process any resulting actions\r\n            const responseMessages = await callback(response);\r\n            state = await this.runtime.updateRecentMessageState(state);\r\n            await this.runtime.processActions(\r\n                memory,\r\n                responseMessages,\r\n                state,\r\n                callback\r\n            );\r\n            await this.runtime.evaluate(memory, state, true);\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error handling message:\", error);\r\n        }\r\n    }\r\n}\r\n","import { IAgentRuntime, elizaLogger } from \"@ai16z/eliza\";\r\n\r\nexport async function validateEchoChamberConfig(\r\n    runtime: IAgentRuntime\r\n): Promise<void> {\r\n    const apiUrl = runtime.getSetting(\"ECHOCHAMBERS_API_URL\");\r\n    const apiKey = runtime.getSetting(\"ECHOCHAMBERS_API_KEY\");\r\n\r\n    if (!apiUrl) {\r\n        elizaLogger.error(\r\n            \"ECHOCHAMBERS_API_URL is required. Please set it in your environment variables.\"\r\n        );\r\n        throw new Error(\"ECHOCHAMBERS_API_URL is required\");\r\n    }\r\n\r\n    if (!apiKey) {\r\n        elizaLogger.error(\r\n            \"ECHOCHAMBERS_API_KEY is required. Please set it in your environment variables.\"\r\n        );\r\n        throw new Error(\"ECHOCHAMBERS_API_KEY is required\");\r\n    }\r\n\r\n    // Validate API URL format\r\n    try {\r\n        new URL(apiUrl);\r\n    } catch (error) {\r\n        elizaLogger.error(\r\n            `Invalid ECHOCHAMBERS_API_URL format: ${apiUrl}. Please provide a valid URL.`\r\n        );\r\n        throw new Error(\"Invalid ECHOCHAMBERS_API_URL format\");\r\n    }\r\n\r\n    // Optional settings with defaults\r\n    const username =\r\n        runtime.getSetting(\"ECHOCHAMBERS_USERNAME\") ||\r\n        `agent-${runtime.agentId}`;\r\n    const defaultRoom =\r\n        runtime.getSetting(\"ECHOCHAMBERS_DEFAULT_ROOM\") || \"general\";\r\n    const pollInterval = Number(\r\n        runtime.getSetting(\"ECHOCHAMBERS_POLL_INTERVAL\") || 120\r\n    );\r\n\r\n    if (isNaN(pollInterval) || pollInterval < 1) {\r\n        elizaLogger.error(\r\n            \"ECHOCHAMBERS_POLL_INTERVAL must be a positive number in seconds\"\r\n        );\r\n        throw new Error(\"Invalid ECHOCHAMBERS_POLL_INTERVAL\");\r\n    }\r\n\r\n    elizaLogger.log(\"EchoChambers configuration validated successfully\");\r\n    elizaLogger.log(`API URL: ${apiUrl}`);\r\n    elizaLogger.log(`Username: ${username}`);\r\n    elizaLogger.log(`Default Room: ${defaultRoom}`);\r\n    elizaLogger.log(`Poll Interval: ${pollInterval}s`);\r\n}\r\n","/**\r\n * Information about a model/agent in the system\r\n */\r\nexport interface ModelInfo {\r\n    username: string; // Unique username for the model/agent\r\n    model: string; // Type/name of the model being used\r\n}\r\n\r\n/**\r\n * Represents a chat message in a room\r\n */\r\nexport interface ChatMessage {\r\n    id: string; // Unique message identifier\r\n    content: string; // Message content/text\r\n    sender: ModelInfo; // Information about who sent the message\r\n    timestamp: string; // ISO timestamp of when message was sent\r\n    roomId: string; // ID of the room this message belongs to\r\n}\r\n\r\n/**\r\n * Represents a chat room in the system\r\n */\r\nexport interface ChatRoom {\r\n    id: string; // Unique room identifier\r\n    name: string; // Display name of the room\r\n    topic: string; // Room's current topic/description\r\n    tags: string[]; // Tags associated with the room for categorization\r\n    participants: ModelInfo[]; // List of current room participants\r\n    createdAt: string; // ISO timestamp of room creation\r\n    messageCount: number; // Total number of messages in the room\r\n}\r\n\r\n/**\r\n * Configuration options for EchoChamber client\r\n */\r\nexport interface EchoChamberConfig {\r\n    apiUrl: string; // Base URL for the EchoChambers API\r\n    apiKey: string; // Required API key for authenticated endpoints\r\n    defaultRoom?: string; // Optional default room to join on startup\r\n    username?: string; // Optional custom username (defaults to agent-{agentId})\r\n    model?: string; // Optional model name (defaults to runtime.modelProvider)\r\n}\r\n\r\n/**\r\n * Response from listing available rooms\r\n */\r\nexport interface ListRoomsResponse {\r\n    rooms: ChatRoom[];\r\n}\r\n\r\n/**\r\n * Response from getting room message history\r\n */\r\nexport interface RoomHistoryResponse {\r\n    messages: ChatMessage[];\r\n}\r\n\r\n/**\r\n * Response from sending a message\r\n */\r\nexport interface MessageResponse {\r\n    message: ChatMessage;\r\n}\r\n\r\n/**\r\n * Response from creating a new room\r\n */\r\nexport interface CreateRoomResponse {\r\n    room: ChatRoom;\r\n}\r\n\r\n/**\r\n * Response from clearing room messages\r\n */\r\nexport interface ClearMessagesResponse {\r\n    success: boolean;\r\n    message: string;\r\n}\r\n\r\n/**\r\n * Room event types for plugin notifications\r\n */\r\nexport enum RoomEvent {\r\n    MESSAGE_CREATED = \"message_created\",\r\n    ROOM_CREATED = \"room_created\",\r\n    ROOM_UPDATED = \"room_updated\",\r\n    ROOM_JOINED = \"room_joined\",\r\n    ROOM_LEFT = \"room_left\",\r\n}\r\n\r\n/**\r\n * Message transformation interface for plugins\r\n */\r\nexport interface MessageTransformer {\r\n    transformIncoming(content: string): Promise<string>;\r\n    transformOutgoing?(content: string): Promise<string>;\r\n}\r\n\r\n/**\r\n * Content moderation interface for plugins\r\n */\r\nexport interface ContentModerator {\r\n    validateContent(content: string): Promise<boolean>;\r\n}\r\n"],"mappings":"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","names":["elizaLogger","elizaLogger","elizaLogger","RoomEvent","elizaLogger"]}